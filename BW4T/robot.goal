init module {
	knowledge {
		% A room is a place with exactly one neighbour, i.e., there is only one way to get to and from that place.
		room(PlaceID) :- zone(_,PlaceID,_,_,Neighbours), length(Neighbours,1).
		
		
		% Color is the color needed to be dropped of at this moment
		nextColorInSeq(Color) :- sequenceIndex(Index),sequence(Colors),element_at(Color,Colors,Index).
		
		%get element X at index K of list [_|L]
		element_at(X,[X|_],0).
		element_at(X,[_|L],K) :- element_at(X,L,K1), K is K1 + 1.
		
        
    	

		% Exercise 2.5 + 2.6: (optional) if needed, insert additional knowledge here.
		
	}
	program {
		% Store map information, i.e., navigation points in the agent's belief base.
		forall bel( percept(zone(ID, Name, X, Y, Neighbours)) ) do insert( zone(ID, Name, X, Y, Neighbours) ).

		% Record the initial state of movement in belief base.
		if bel( percept(state(State)) ) then insert( state(State) ).
		
		
		
		% Adopt an initial room to go to here
		if bel( room(Place) ) then adopt( in(Place) ).
		
		

		% Exercise 2.1a: insert rules for processing percepts that are sent only at the beginning of a session, 
		%  and/or need to be initialized.
		forall bel(percept(place(Place))) do insert(place(Place)).
		
		%record initial sequenceIndex
		if bel(percept(sequenceIndex(Index))) then insert(sequenceIndex(Index)).
		
		
		
		
		%record the sequence in belief base.
		if bel(percept(sequence(Colors))) then insert(sequence(Colors)).
		
		%record the next color in the belief base.
		if bel(nextColorInSeq(Color)) then insert (nextColor(Color)).
		
		
		
		
		
	}	
	actionspec {
		% The goTo action makes the agent move to a place (location) in the BW4T environment.
		% As long as the agent has not arrived at the place it is going to, it will be in "traveling" mode.
		goTo(PlaceID) {
            pre { not(state(traveling)),  zone(_,PlaceID,_,_,_) }
			post { true }
		}

		% The goToBlock(Block) action makes the agent move to a block.
		% The agent will have arrived when it is in a room, at the desired block (block with the right color)
		goToBlock(BlockID) {
			pre { in(Room), color(Block, nextColorInSeq(Color)), not(atBlock(BlockID)) }
			post { true }
		}
		
		% The pickUp action makes the agent pick up a block and therefore removing it from the ground.
		pickUp {
			pre { not(holding(Block)) }
			post { not(at(Block)) }
		}
		
		% The putDown action needs work.
		putDown {
			pre { holding(Block) }
			post { if (in(Room)) then (at(Block))), not(holding(Block)) }
		} 

	}
}

main module [exit=never] {
	program {
		if a-goal( in(Place) ) then goTo(Place).


		% Exercise 2.6a: insert code for action rules that makes the agent deliver a block when it 
		%   knows about a block that can be delivered.
		
	}
}

event module {
	program {
	    % Update the agent's state of movement.
		forall bel( state(State), percept(state(NewState)) ) do delete( state(State) ) + insert( state(NewState) ).
		
		% Record when we are entering or leaving a room, record visited Room after leaving
		forall bel(percept(in(Room))) do insert(in(Room)).
		forall bel(percept(not(in(Room)))) do delete(in(Room))+ insert(visited(Room)).
		
		%Record when we are at a certain place
		forall bel(at(Place), percept(at(NewPlace))) do delete(at(Place)) + insert(at(NewPlace)).
		
		%Record when we are at a block
		forall bel(percept(atBlock(Block))) do insert(atBlock(Block)).
		forall bel(percept(not(atBlock(Block)))) do delete (atBLock(Block)).
		
		 	
 		
 		%record when we hold a block
		forall bel( percept(holding(Block)) ) do insert( holding(Block) ).
		forall bel( percept(not(holding(Block))) ) do delete( holding(Block) ).	
		
		%records a current sequence index update
		forall bel(sequenceIndex(Index), percept(sequenceIndex(NewIndex))) do delete(sequenceIndex(Index)) + insert(sequenceIndex(NewIndex)).
		
		%update nextcolor if different from nextColorInSeq.
		forall bel(nextColorInSeq(NewColor), nextColor(Color)) do delete(nextColor(Color))+insert (nextColor(NewColor)).
		
		%record when we percieve a block is a certain color at a certain place
		forall bel( percept(color(BlockID, ColorID)), at(PlaceID) ) do insert( block(BlockID, ColorID, PlaceID) ).
 		forall bel( at(PlaceID), block(BlockID, ColorID, PlaceID),percept(not(color(BlockID, ColorID))) ) do delete( block(BlockID, ColorID, PlaceID) ). 
		
		%if robot does not now a block of wanted color exits, go to new room 
		forall bel(nextColor(Color), not(block(Block,Color,_)), not(visited(Place)),room(Place)) do adopt (in(Place)).
		%if robot nows a block it wants exists, adopt to go to block
		%forall bel(nextColorInSeq(Color), color(Block,Color)) do adopt( at(Block)).
		
		
		
		% Exercise 2.6b: insert code for goal management that makes the agent deliver a block when it 
		%   knows about a block that can be delivered. (if needed)
		
	}
}

