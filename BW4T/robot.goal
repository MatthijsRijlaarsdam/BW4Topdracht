init module {
	knowledge {
		% A room is a place with exactly one neighbour, i.e., there is only one way to get to and from that place.
		room(PlaceID) :- zone(_,PlaceID,_,_,Neighbours), length(Neighbours,1).
		
		
		% Color is the color needed to be dropped of at this moment
		nextColorInSeq(Color) :- sequenceIndex(Index),sequence(Colors),element_at(Color,Colors,Index).
		
		%get element X at index K of list [_|L]
		element_at(X,[X|_],0).
		element_at(X,[_|L],K) :- element_at(X,L,K1), K is K1 + 1.
		
        
    	

		% Exercise 2.5 + 2.6: (optional) if needed, insert additional knowledge here.
		
	}
	program {
		% Store map information, i.e., navigation points in the agent's belief base.
		forall bel( percept(zone(ID, Name, X, Y, Neighbours)) ) do insert( zone(ID, Name, X, Y, Neighbours) ).

		% Record the initial state of movement in belief base.
		if bel( percept(state(State)) ) then insert( state(State) ).
		
		
		
		% Adopt initial goals.
		forall bel( room(Place) ) do adopt( in(Place) ).
		

		% Exercise 2.1a: insert rules for processing percepts that are sent only at the beginning of a session, 
		%  and/or need to be initialized.
		forall bel(percept(place(Place))) do insert(place(Place)).
		
		%record initial sequenceIndex
		if bel(percept(sequenceIndex(Index))) then insert(sequenceIndex(Index)).
		
		
		
		
		%record the sequence in belief base.
		if bel(percept(sequence(Colors))) then insert(sequence(Colors)).
		
		
		
		
		
		
	}	
	actionspec {
		% The goTo action makes the agent move to a place (location) in the BW4T environment.
		% As long as the agent has not arrived at the place it is going to, it will be in "traveling" mode.
		goTo(PlaceID) {
            pre { not(state(traveling)),  zone(_,PlaceID,_,_,_) }
			post { true }
		}

		% The goToBlock(Block) action makes the agent move to a block.
		% The agent will have arrived when it is in a room, at the desired block (block with the right color)
		goToBlock(BlockID) {
			pre { in(Room), color(Block, nextColorInSeq(Color)) }
			post { atBlock(BlockID }
		}
		
		% The pickUp action makes the agent pick up a block and therefore removing it from the ground.
		pickUp {
			pre { not(holding(Block)) }
			post { true, not(at(Block)) }
		}
		
		% The putDown action needs work.
		putDown {
			pre { holding(Block) }
			post { (if (in(Room)) then (at(Block)))), not(holding(Block)) }
		}
	}
}

main module [exit=nogoals] {
	program {
		if a-goal( in(Place) ) then goTo(Place).

		% Exercise 2.5a: insert code for action rules that allows an agent to systematically search for blocks.

		% Exercise 2.6a: insert code for action rules that makes the agent deliver a block when it 
		%   knows about a block that can be delivered.
		
	}
}

event module {
	program {
	    % Update the agent's state of movement.
		forall bel( state(State), percept(state(NewState)) ) do delete( state(State) ) + insert( state(NewState) ).
		
		% Record when we are entering or leaving a room.
		forall bel(percept(in(Room))) do insert(in(Room)).
		forall bel(percept(not(in(Room)))) do delete(in(Room)).
		
		%Record when we are at a certain place
		forall bel(at(Place), percept(at(NewPlace))) do delete(at(Place)) + insert(at(NewPlace)).
		
		%Record when we are at a block
		forall bel(percept(atBlock(Block))) do insert(atBlock(Block)).
		forall bel(percept(not(atBlock(Block)))) do delete (atBLock(Block)).
		
		%record when we percieve a block is a certain color, and rember this information
		forall bel(percept(color(Block,Color)), not(color(Block,Color))) do insert(color(Block,Color)).
 		%forall bel(color(Block,Color), not(percept(color(Block,Color)))) do delete(color(Block,Color)). 	
 		
 		%record when we hold a block
		forall bel( percept(holding(Block)) ) do insert( holding(Block) ).
		forall bel( percept(not(holding(Block))) ) do delete( holding(Block) ).	
		
		%records a current sequence index update
		forall bel(sequenceIndex(Index), percept(sequenceIndex(newIndex))) do delete(sequenceIndex(Index)) + insert(sequenceIndex(newIndex)).
		
		% Exercise 2.5b: insert code for goal management that allows an agent to systematically search for blocks. (if needed)
		
		% Exercise 2.6b: insert code for goal management that makes the agent deliver a block when it 
		%   knows about a block that can be delivered. (if needed)
		
	}
}

